vitunes

   workflow

      * user stories
         on start, there are 3 major content areas
            - player: shows initial play status (probably nothing)
               . but it can be an ongoing playing if server is playing
               ! PROPERTY: player.[mode|state|progress|volume|plist+mfile]
            - library: shows library(all files) and all playlists
                  ! PROPERTY: plistdb.[nameS] [ + mfiledb.* ]
              -or- IF a playlist is playing it shows that playlist scrolled
                  ! PROPERTY: player.* + plistdb.* + mfiledb.*
            - file window: shows contents of playlist (all files)
               ! PROPERTY: above + load "library" view
            - IF something is playing THEN the playlist/file are indicated as
               such
               ! PROPERTY: player + plistdb + mfiledb
         user can then
            - select a playlist in the library to load contents in file window
               ! PROPERTY: plistdb + mfiledb[if selected 'all']
            - select a file in file window to play
               ! ACTION: player.play(plist, mfile#)
            - pause/play/stop, seek, volume +/-, change play mode
               ! ACTION: player
            - can also play a playlist (starts at the begining of that plist)
               ! ACTION: player
         when viewing a playlist, in the file window they can
            - sort that playlist by the various fields (artist, album, etc)
               . that sort is NOT sticky for that playlist
                  . unless "auto save" is enabled
               . -or- can chose to save results to a new, named playlist
            - filter that playlist by a freetext spec
               . any changes are NOT sticky / playlist is marked "modified"
                  . unless "auto save" is enabled
               . -or- can chose to save results to a new, named playlist
            - copy files from this playlist [move to another] and paste them
               . any changes are NOT sticky / playlist is marked "modified"
                  . unless "auto save" is enabled
            - cut/remove files from a playlist
               . any changes are NOT sticky / playlist is marked "modified"
                  . unless "auto save" is enabled
         for managing contents, user can
            - scan directories recursively to add content
               . PERMENANTLY
            - add files explicitly
               . PERMENANTLY
            - view raw tag info from a file
            - modify tag info in a file
         the playing playlist and file are indicated
            - the library view indicates the playing playlist
            - the file view view indicates the playing file
            - the player view shows details on the playing file
         to create new playlists the user can
            - add a new empty playlist, with a name
            - save the results of a filter/sort from another playlist to a new
               named playlist
            - create a copy of a playlist, with a new name

      * For ANY ui capable of the above, these are ALL of the TOP-LEVEL
         PROPERTIES the ui is aware,
         ACTIONS the ui is capable of performing, and
         EVENTS the ui must be aware of happening

         - PROPERTIES they must know (static, initial state)
            . player  - initial state of player
               . player.mode     = [linear | loop | random]
               . player.state    = [pauseed | playing | stopped]
               . player.progress = <secsTotal, secsDone>
               . player.volume   = n%
               . player.content  = plist(name) + mfile(number)
            . plistdb - all playlists and their order
               . plistdb.all     = list of all plists
               . for each playlist
                  - name
                  - contents  = array of mfiles
            . mfiledb - all known mfiles
               . mfiledb.all     = list of all mfiles
               . for each mfile
                  - all the metainfo

         - ACTIONS they can perform
            . player.mode(mode)              // [linear | loop | random]
            . player.pause()/resume()/stop() // these are "state"
            . player.seek(+/- n seconds)
            . player.volume(+/- n%)
            . player.play(plist, index)      // <name, number>
            . player.play_next(int n)        // # next
            . player.play_prev(int n)        // # prev

            . plistdb.add_empty_playlist(name)
            . plistdb.delete_playlist(name)
            . plistdb.copy_playlist(name, newName)
            . plistdb.rename_playlist(oldName, newName)

            . plistdb.plist_add_file(name, mfile*)
            . plistdb.plist_add_files(name, mfile**)
            . plistdb.plist_delete_file(name, mfile*)
            . plistdb.plist_delete_files(name, mfile**)
            . plistdb.plist_sort(name, sort-spec)
            . plistdb.plist_filter(name, filter-spec)

         - EVENTS they can respond to
            . shutdown()
            . player.mode_changed(newMode)         // [linear | loop | random]
            . player.state_changed(newState)       // [paused | playing | stopped]
            . player.progress_changed(newProgress) // <secsTotal, secsDone>
            . player.volume_changed(n%)            // n%
            . player.content_changed(plist, idx)   // <name, number> [mfile]

            . plistdb.addedPlist(plist)
            . plistdb.removedPlist(name)
            . plistdb.renamedPlist(oldName, newName)
            . plistdb.changedPlist(name, newPlist)
            . reordered playlists


   Starting the object breakdown

   - mfile = core object wrapping a bit of "playable content"
   - plist = core object wrapping a "playable list of content"
   - mfiledb = database of all "playable content"
   - plistdb = database of all "playable playlists"
   - player = object wrapper media player backend

   - mfile
      core properties & operational features of a media file/stream

      mfile struct
         char* realpath/url
         char* artist/alubum/genre/description/etc
         int   year
         int   track/no
         time  last_mod_timestamp
         hash  md5sum   // maybe?

      API
         mfile* new()
         void   free(mfile*)

   - taglib wrapper
      wraps all taglib uses behind mfile

      API
         mfile taglib_extract(char* relativepath)
         bool  taglib_save_tags(mfile*)

   - plist
      core properties & operational features of a playlist

      plist struct
         char*  realpath
         char*  name
         mfile* contents
         bool   unsaved_changes

      API
         plist* new()
         void   free(plist*)
         plist* dup(plist*)

   - plist operations
      std operations on playlists

      API
         // these return new versions so undo/redo can be supported
         plist* sort(plist*, sort-spec)
         plist* filter(plist*, filter-spec)

   - mfiledb
      houses all mfiles and operations about them

      API
         load(char*)
         save()

         scan_dirs(char*,     TEMP_OR_PERMENANT)
         scan_files(char*,    TEMP_OR_PERMENANT)
         add_url(url, props,  TEMP_OR_PERMENANT)

         update()

         // XXX mfile* lookup(file)
         expose_contents_somehow(**mfile)

   - plistdb
      houses all plists and operations on them
      NAMES ARE UNIQUE

      playlist order
         plist* all

      API
         load(mfiledb*, char *dir_to_playlists)
         save()
         scan_dir(char*)
         int    write_to_file(plist*, char* realpath)
         plist* load_from_file(plist*, char* realpath)


vitunes main

   db operations

      - command line
         * vitunes add dir1 [dir2 ...]
            - mfiledb.load(default)
            - mfiledb.add_dir(dir1)
               . log = stdout
               . recursively scan dir
               . for each file found...
                  . mfiledb.add_file(file)
            - mfiledb.save()

         * vitunes add file1 [file2 ...]
            - mfiledb.load(default)
            - mfiledb.add_file(file1)
               . if (mfile = taglib_extract())
                  . if (fileindex.find(mfile.path))
                     . fileindex[file] = mfile
                     . log: added
                  . else
                     . fileindex[file] = mfile
                     . log: updated
            - mfiledb.save()

         * vitunes update
            - mfiledb.load(default)
            - mfiledb.update()
               . for each file in fileindex
                  . mfileV1 = fileindex[i]
                  . if (mfileV1.type = url)
                     . continue
                  . mfileV2 = taglib_extract(mfileV1.path)
                  . if (mfileV1 != mfileV2)
                     . filedindex[i] = mfileV2
                     . log: updated
            - mfiledb.save()

         * vitunes addurl url [props]
            - mfiledb.load(default)
            - mfiledb.addurl(url, props);
               . if mfile = fileindex.find(url)
                  . mfile.prop = options.prop (for each prop)
               . else
                  . mfile = new()
                  . mfile.path = url
                  . mfile.prop = options.prop (for each prop)
                  . fileindex[url] = mfile
            - mfiledb.save()

      - needs to sync w/ running version!

   playlist operations

      initial runtime setup(mfiledb, plist_dir, plistdb)

         * plist LIBRARY(mfiledb.all())
            - p = new()
            - p.name = LIBRARY
            - p.mutable = false
            - p.unsaved_change = false
            - p.contents = convert(mfiledb)
            - plistdb_set_library(p)

         * plistdb.scan_dir(plist_dir)
            - search dir, for each file
               . plist = plist_load_from_file(file, mfiledb)
               . plistdb.add(plist)

         * plist_load_from_file(file, db)
            - p = plist_new(file)
            - p.name = strip_extension(file)
            - p.realpath = file
            - open file
            - for each file
               . mfile = mfiledb.lookup(file)
               . p.contents.add(mfile)
            - close file
            - return p

      runtime use

         * adding a playlist
            . plist = new()
            . plistdb.add(plist)

         * sorting a playlist

         * filtering a playlist

      * core startup
         if [ -f file ] configfile = file else configfile = ~/.vitunes.conf
         config.load(configfile)
         config.parse(params)

         mfiledb.load(config.mfiledb)
         plistdb.load(config.plistdb)
         mplayer.init(config.mplayer)

         ui.init(config.ui)
            // this might init multiple ui's
            // e.g. a console one and a web one
            // SHOULD NOT INITIATE ANY UI JUST YET, BUT RATHER JUST...
            //    1. copy any setting sover
            //    2. inject mfiledb/plistdb/player
            //    3. ensure the backends *can* start


