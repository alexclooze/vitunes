vitunes

   - mfile
      core properties & operational features of a media file/stream

      mfile struct
         str   realpath/url
         str   artist/alubum/genre/description/etc
         int   year
         int   track/no
         hash  md5sum
         time  last_mod_timestamp

      API
         new()
         free()
         compare(mfile* l, mfile* r)   // content compare

   - taglib wrapper
      wraps all taglib uses behind mfile

      API
         mfile = taglib_extract(str relativepath)
         bool  = taglib_save_tags(mfile)

   - plist
      core properties & operational features of a playlist

      plist struct
         str    name
         str    realpath
         bool   unsaved_changes
         mfile* contents

      API
         new()
         free()
         dup(plist*)

   - mfiledb
      houses all mfiles and operations about them

      API
         load(char*)
         save()

         add_dir(char*)
         add_file(char*)
         add_url(url, props)
         update()

         // XXX mfile* lookup(file)
         expose_contents_somehow(**mfile)

   - plistdb
      houses all plists and operations on them
      NAMES ARE UNIQUE

      playlist order
         plist* all

      API
         load(mfiledb*, char *dir_to_playlists)
         save()
         scan_dir(char*)
         // XXX set_library(plist*)

   - plist operations
      std operations on playlists

      sort(plist*, sort-spec)
      filter(plist*, filter-spec)




vitunes main

   db operations

      - command line
         * vitunes add dir1 [dir2 ...]
            - mfiledb.load(default)
            - mfiledb.add_dir(dir1)
               . log = stdout
               . recursively scan dir
               . for each file found...
                  . mfiledb.add_file(file)
            - mfiledb.save()

         * vitunes add file1 [file2 ...]
            - mfiledb.load(default)
            - mfiledb.add_file(file1)
               . if (mfile = taglib_extract())
                  . if (fileindex.find(mfile.path))
                     . fileindex[file] = mfile
                     . log: added
                  . else
                     . fileindex[file] = mfile
                     . log: updated
            - mfiledb.save()

         * vitunes update
            - mfiledb.load(default)
            - mfiledb.update()
               . for each file in fileindex
                  . mfileV1 = fileindex[i]
                  . if (mfileV1.type = url)
                     . continue
                  . mfileV2 = taglib_extract(mfileV1.path)
                  . if (mfileV1 != mfileV2)
                     . filedindex[i] = mfileV2
                     . log: updated
            - mfiledb.save()

         * vitunes addurl url [props]
            - mfiledb.load(default)
            - mfiledb.addurl(url, props);
               . if mfile = fileindex.find(url)
                  . mfile.prop = options.prop (for each prop)
               . else
                  . mfile = new()
                  . mfile.path = url
                  . mfile.prop = options.prop (for each prop)
                  . fileindex[url] = mfile
            - mfiledb.save()

      - needs to sync w/ running version!

   playlist operations

      initial runtime setup(mfiledb, plist_dir, plistdb)

         * plist LIBRARY(mfiledb.all())
            - p = new()
            - p.name = LIBRARY
            - p.mutable = false
            - p.unsaved_change = false
            - p.contents = convert(mfiledb)
            - plistdb_set_library(p)

         * plistdb.scan_dir(plist_dir)
            - search dir, for each file
               . plist = plist_load_from_file(file, mfiledb)
               . plistdb.add(plist)

         * plist_load_from_file(file, db)
            - p = plist_new(file)
            - p.name = strip_extension(file)
            - p.realpath = file
            - open file
            - for each file
               . mfile = mfiledb.lookup(file)
               . p.contents.add(mfile)
            - close file
            - return p

      runtime use

         * adding a playlist
            . plist = new()
            . plistdb.add(plist)

         * sorting a playlist

         * filtering a playlist

      * core startup
         if [ -f file ] configfile = file else configfile = ~/.vitunes.conf
         config.load(configfile)
         config.parse(params)

         mfiledb.load(config.mfiledb)
         plistdb.load(config.plistdb)
         mplayer.init(config.mplayer)

         ui.init(config.ui)
            // this might init multiple ui's
            // e.g. a console one and a web one
            // SHOULD NOT INITIATE ANY UI JUST YET, BUT RATHER JUST...
            //    1. copy any setting sover
            //    2. inject mfiledb/plistdb/player
            //    3. ensure the backends *can* start


   ux / workflow

      * user stories
         on start, there are 3 major content areas
            - player: shows initial play status (probably nothing)
               . but it can be an ongoing playing if server is playing
            - library: shows library(all files) and all playlists
            - file window: shows contents of 'library' (all files)
            - IF something is playing THEN the playlist/file are indicated as
               such
         user can then
            - select a playlist in the library to load contents in file window
            - select a file in file window to play
            - pause/play/stop, seek, volume +/-, change play mode
            - can also play a playlist (starts at the begining of that plist)
         when viewing a playlist, in the file window they can
            - sort that playlist by the various fields (artist, album, etc)
               . that sort is NOT sticky for that playlist
                  . unless "auto save" is enabled
               . -or- can chose to save results to a new, named playlist
            - filter that playlist by a freetext spec
               . any changes are NOT sticky / playlist is marked "modified"
                  . unless "auto save" is enabled
               . -or- can chose to save results to a new, named playlist
            - copy files from this playlist [move to another] and paste them
               . any changes are NOT sticky / playlist is marked "modified"
                  . unless "auto save" is enabled
            - cut/remove files from a playlist
               . any changes are NOT sticky / playlist is marked "modified"
                  . unless "auto save" is enabled
         for managing contents, user can
            - scan directories recursively to add content
            - add files explicitly
            - view raw tag info from a file
            - modify tag info in a file
         the playing playlist and file are indicated
            - the library view indicates the playing playlist
            - the file view view indicates the playing file
            - the player view shows details on the playing file
         to create new playlists the user can
            - add a new empty playlist, with a name
            - save the results of a filter/sort from another playlist to a new
               named playlist
            - create a copy of a playlist, with a new name

      * For ANY ui capable of the above, these are ALL of the....

         - PROPERTIES they must know (static, initial state)
            . player  - initial state of player
            . plistdb - all playlists and their order
            . mfiledb - all known mfiles

         - ACTIONS they can perform
            . player.mode(mode)              // [linear | loop | random]
            . player.pause()/resume()/stop() // these are "state"
            . player.seek(+/- n seconds)
            . player.volume(+/- n%)
            . player.play(plist, index)      // <name, number>
            . player.play_next(int n)        // # next
            . player.play_prev(int n)        // # prev

            . plistdb.add_empty_playlist(name)
            . plistdb.delete_playlist(name)
            . plistdb.copy_playlist(name, newName)
            . plistdb.rename_playlist(oldName, newName)

            . plistdb.plist_add_file(name, mfile*)
            . plistdb.plist_add_files(name, mfile**)
            . plistdb.plist_delete_file(name, mfile*)
            . plistdb.plist_delete_files(name, mfile**)
            . plistdb.plist_sort(name, sort-spec)
            . plistdb.plist_filter(name, filter-spec)

         - EVENTS they can respond to
            . shutdown()
            . player.mode_changed(newMode)         // [linear | loop | random]
            . player.state_changed(newState)       // [paused | playing | stopped]
            . player.progress_changed(newProgress) // <secsTotal, secsDone>
            . player.volume_changed(n%)            // n%
            . player.content_changed(plist, idx)   // <name, number> [mfile]

            . plistdb.addedPlist(plist)
            . plistdb.removedPlist(name)
            . plistdb.renamedPlist(oldName, newName)
            . plistdb.changedPlist(name, newPlist)
            . reordered playlists


